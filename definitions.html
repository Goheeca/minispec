<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CL MiniSpec: Definitions</title>
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<link rel="shortcut icon" href="./include/fav.png">-->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <link rel="stylesheet" href="./include/bootstrap/css/bootstrap.css">
		<link rel="stylesheet" href="https://raw.github.com/jharding/typeahead.js-bootstrap.css/master/typeahead.js-bootstrap.css">
    <link rel="stylesheet" href="./include/highlight/themes/github.css">
    <link rel="stylesheet" href="./include/style.css">
    <meta name="description" content="">
  </head>
  <body>
    <header>
<nav class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container-fluid">
      <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
			<a href="./index.html" class="brand">Common Lisp MiniSpec</a>
			<form class="navbar-search pull-right"><input type="search" placeholder="symbol" class="search-query span2"></input></form>
      <div class="nav-collapse collapse">
        <ul class="nav pull-right">
          <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Definitions<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="./definitions.html#variables">Variables</a></li>
              <li><a href="./definitions.html#functions">Functions</a></li>
              <li><a href="./definitions.html#macros">Macros</a></li>
            </ul>
          </li>
					<li><a href="./lists.html">Lists</a></li>
					<li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Structures<b class="caret"></b></a>
            <ul class="dropdown-menu">
							<li class="nav-header"><a href="./list-structures.html">List Structures</a></li>
							<li><a href="./list-structures.html#set">Set</a></li>
              <li><a href="./list-structires.html#tree">Tree</a></li>
							<li><a href="./list-structures.html#plist">Property List</a></li>
							<li><a href="./list-structures.html#alist">Association List</a></li>
							<li class="nav-header"><a href="./arrays.html">Array</a></li>
							<li><a href="./arrays.html">Array</a></li>
							<li><a href="./vectors.html">Vector</a></li>
							<li class="nav-header"><a href="./data-structures.html">Objects</a></li>
							<li><a href="./data-structures.html#hash-tables">Hash Table</a></li>
							<li><a href="./data-structures.html#structs">Structs</a></li>
							<li><a href="./clos.html">Common Lisp Object System</a></li>
            </ul>
          </li>
					<li><a href="./strings.html">Strings</a></li>
					<li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">Types<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="#">Numbers</a></li>
              <li><a href="#">Characters</a></li>
            </ul>
          </li>
          <li><a href="./math.html">Math</a></li>
          <li><a href="./iteration.html">Iteration</a></li>
          <li><a href="./control.html">Control</a></li>
					<li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown">More<b class="caret"></b></a>
            <ul class="dropdown-menu">
							<li><a href="./time.html">Time</a></li>
							<li><a href="./output.html">Output</a></li>
              <li><a href="./regular-expressions.html">Regular Expressions</a></li>
            </ul>
          </li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</nav>
    </header>
    <div id="container" class="container-fluid">
      <div class="row-fluid">
        <aside class="span3">
          <nav class="well" data-spy="affix">
<ul class="nav nav-list">
  <li><a href="#define-variables-functions-macros" class="nav-header">Define Variables, Functions, Macros</a></li>
  <li><a href="#variables" class="nav-header">Variables</a></li>
  <li><a href="#defparameter-name-value-doc-name">defparameter</a></li>
  <li><a href="#defvar-name-value-doc-name">defvar</a></li>
  <li><a href="#defconstant-name-value-doc-name">defconstant</a></li>
  <li><a href="#setf-place-value-result">setf</a></li>
  <li><a href="#let-var-var-value-forms-result">let</a></li>
  <li><a href="#multiple-value-bind-vars-values-form-body-forms-result">multiple-value-bind</a></li>
  <li><a href="#destructuring-bind-lambda-list-expression-forms-result">destructuring-bind</a></li>
  <li><a href="#multiple-value-setq-vars-form-result">multiple-value-setq</a></li>
  <li><a href="#progv-symbols-values-forms-result">progv</a></li>
  <li><a href="#shiftf-place-newvalue-first-value">shiftf</a></li>
  <li><a href="#rotatef-places-nil">rotatef</a></li>
  <li><a href="#makunbound-symbol-symbol">makunbound</a></li>
  <li><a href="#functions" class="nav-header">Functions</a></li>
  <li><a href="#defun-name-lambda-list-declare-doc-form-name">defun</a></li>
  <li><a href="#lambda-lambda-list-declare-doc-form-function">lambda</a></li>
  <li><a href="#labels-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result">labels</a></li>
  <li><a href="#function-name-function">function</a></li>
  <li><a href="#funcall-function-rest-args-result">funcall</a></li>
  <li><a href="#apply-function-args-arg-list-result">apply</a></li>
  <li><a href="#multiple-value-call-function-forms-result">multiple-value-call</a></li>
  <li><a href="#values-objects-objects">values</a></li>
  <li><a href="#values-list-list-objects">values-list</a></li>
  <li><a href="#multiple-value-list-form-list">multiple-value-list</a></li>
  <li><a href="#nth-value-n-form-object">nth-value</a></li>
  <li><a href="#complement-function-complement-function">complement</a></li>
  <li><a href="#constantly-value-function">constantly</a></li>
  <li><a href="#identity-object-object">identity</a></li>
  <li><a href="#function-lambda-expression-function-lambda-expression-closure-p-name">function-lambda-expression</a></li>
  <li><a href="#fdefinition-name-definition">fdefinition</a></li>
  <li><a href="#fmakunbound-name-name">fmakunbound</a></li>
  <li><a href="#function-composition" class="nav-header">Function Composition</a></li>
  <li><a href="#alexandriacompose-fn-rest-fns-function">compose</a></li>
  <li><a href="#alexandriamultiple-value-compose-fn-rest-fns-function">multiple-value-compose</a></li>
  <li><a href="#alexandriadisjoin-pred-rest-preds-function">disjoin</a></li>
  <li><a href="#alexandriaconjoin-pred-rest-preds-function">conjoin</a></li>
  <li><a href="#alexandriacurry-fn-rest-args-function">curry</a></li>
  <li><a href="#alexandriarcurry-fn-rest-args-function">rcurry</a></li>
  <li><a href="#macros" class="nav-header">Macros</a></li>
  <li><a href="#defmacro-name-lambda-list-declare-doc-forms-name">defmacro</a></li>
  <li><a href="#macrolet-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result">macrolet</a></li>
  <li><a href="#define-symbol-macro-symbol-expansion-symbol">define-symbol-macro</a></li>
  <li><a href="#symbol-macrolet-symbol-expansion-declare-forms-result">symbol-macrolet</a></li>
  <li><a href="#define-modify-macro-name-lambda-list-function-doc-name">define-modify-macro</a></li>
  <li><a href="#defsetf-access-fn-update-fn-doc-access-fn">defsetf</a></li>
  <li><a href="#get-setf-expansion-place-optional-env-vars-vals-store-vars-writer-form-reader-form">get-setf-expansion</a></li>
  <li><a href="#define-setf-expander-access-fn-lambda-list-declaration-doc-form-access-fn">define-setf-expander</a></li>
</ul>
          </nav>
        </aside>
        <article class="span9">
<h1 id="define-variables-functions-macros">Define Variables, Functions, Macros</h1>
<ul>
<li><a href="#variables">Variables</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#macros">Macros</a></li>
</ul>
<p>Style Guides</p>
<ul>
<li><a href="http://www.cliki.net/Naming%20conventions">Naming Conventions</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml">Google Common Lisp Style Guide</a></li>
</ul>
<h2 id="variables">Variables</h2>
<h3 id="defparameter-name-value-doc-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpar.htm">defparameter</a> name value [doc] &rArr; name</h3>
<p>Unconditionally assign <em>value</em> to a global dynamic variable. The convention for naming a (global) special variable is: <code>*name*</code>.</p>
<pre><code>(defparameter *x* 1) ;&rArr; *X*</code></pre>
<h3 id="defvar-name-value-doc-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpar.htm">defvar</a> name [value [doc]] &rArr; name</h3>
<p>Unless bound already, assign <em>value</em> to a global dynamic variable. The convention for naming a (global) special variable is: <code>*name*</code>.</p>
<pre><code>(defvar *x* &#39;a) ;&rArr; *X*
(defvar *x* &#39;b)
*x*             ;&rArr; A</code></pre>
<h3 id="defconstant-name-value-doc-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcon.htm">defconstant</a> name value [doc] &rArr; name</h3>
<p>Assign <em>value</em> to a global constant variable. A constant can be redefined by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcon.htm">defconstant</a>. The convention for naming a constant is: <code>+name+</code>.</p>
<pre><code>(defconstant +x+ &#39;a) ;&rArr; +X+
(setf +x+ &#39;b)        ;&rArr; [error]</code></pre>
<h3 id="setf-place-value-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a> {place value}* &rArr; result*</h3>
<p>Sets the value of <em>place</em> to <em>value</em>. Multiple pairs are set sequentially, use <code>psetf</code> to set in parallel. <code>setf</code> works with symbols and forms, and is preferred, while <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_setq.htm">setq</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_psetq.htm">psetq</a> can only set symbols.</p>
<h3 id="let-var-var-value-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let</a> ({var | (var [value])}*) forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with <em>vars</em> lexically bound (or <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">NIL</a>) to values, assigned in parallel. Use <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let*</a> to assign sequentially.</p>
<pre><code>(let ((x 1))
  (list x))       ;&rArr; (1)

(let* ((x 1)
       (y (+1 x)))
  (list x y))      ;&rArr; (1 2)</code></pre>
<h3 id="multiple-value-bind-vars-values-form-body-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_multip.htm">multiple-value-bind</a> (vars*) values-form body-forms* &rArr; result*</h3>
<p>Evaluate <em>body-forms</em> with <em>vars</em> lexically bound to the return values of <em>values-form</em>. Return values of <em>body-forms</em>.</p>
<pre><code>(multiple-value-bind (q r) (floor 7.5)
  (list q r))                          ;&rArr; (7 0.5)</code></pre>
<h3 id="destructuring-bind-lambda-list-expression-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_destru.htm">destructuring-bind</a> lambda-list expression forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with variables from tree <em>lambda-list</em> bound to corresponding elements of tree <em>expression</em>, and return their values.</p>
<ul>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_de.htm">HyperSpec: Destructuring Lambda Lists</a></li>
<li><a href="http://www.gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html#destructuring-bind">PCL: Destructuring-Bind</a></li>
</ul>
<pre><code>(destructuring-bind (a b c) (list 1 (list 2 20) 3)
  (list a b c))       ;&rArr; (1 (2 20) 3)

(destructuring-bind (a (b &amp;optional c) d) (list 1 (list 2) 3)
  (list a b c d))     ;&rArr; (1 2 NIL 3)

(destructuring-bind (&amp;whole whole &amp;key a b c) (list :c 3 :b 2 :a 1)
  (list a b c whole)) ;&rArr; (1 2 3 (:C 3 :B 2 :A 1))</code></pre>
<h3 id="multiple-value-setq-vars-form-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_mult_2.htm">multiple-value-setq</a> (vars) form &rArr; result</h3>
<p>Assign multiple values returned by <em>form</em> to <em>vars</em>.</p>
<pre><code>(multiple-value-setq (a b) (values 1 2))</code></pre>
<h3 id="progv-symbols-values-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_progv.htm">progv</a> symbols values forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with locally established dynamic bindings of <em>symbols</em> to <em>values</em>.</p>
<pre><code>(setf *a* 1)
(progv &#39;(*a*) &#39;(2)
  (print *a*))     ;&rArr; [prints 2]</code></pre>
<h3 id="shiftf-place-newvalue-first-value"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_shiftf.htm">shiftf</a> place* newvalue &rArr; first-value</h3>
<p>Store <em>newvalue</em> in rightmost <em>place</em>, shifting values of places left, returning first <em>place</em>.</p>
<pre><code>(setf a :a b :b)
(shiftf a b :c)  ;&rArr; :A
(list a b)       ;&rArr; (:B :C)</code></pre>
<h3 id="rotatef-places-nil"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_rotate.htm">rotatef</a> places* &rArr; nil</h3>
<p>Rotate values of <em>places</em> left, the first becoming new last place’s value.</p>
<pre><code>(setf a :a b :b c :c)
(rotatef a b c)       ;&rArr; NIL
(list a b c)          ;&rArr; (:B :C :A)</code></pre>
<h3 id="makunbound-symbol-symbol"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_makunb.htm">makunbound</a> symbol &rArr; symbol</h3>
<p>Delete a special variable, if it exists.</p>
<pre><code>(setf a 1)
(boundp &#39;a)     ;&rArr; T
(makunbound &#39;a) ;&rArr; A
(boundp &#39;a)     ;&rArr; NIL</code></pre>
<h2 id="functions">Functions</h2>
<h3 id="defun-name-lambda-list-declare-doc-form-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defun.htm">defun</a> name lambda-list [[declare* | doc]] form* &rArr; name</h3>
<p>Define a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> with a given <em>name</em>, which acts as an implicit <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_block.htm">block</a> when evaluating <em>forms</em>. Optionally <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> type information about the function parameters.</p>
<pre><code>(defun adder (a b)
  (declare (number a b))
  &quot;Sum numbers and return the result.&quot;
  (+ a b))

(adder 3 4) ;&rArr; 7</code></pre>
<h3 id="lambda-lambda-list-declare-doc-form-function"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_lambda.htm">lambda</a> lambda-list [[declare* | doc]] form* &rArr; function</h3>
<p>Return an anonymous <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a>.</p>
<pre><code>(funcall #&#39;(lambda (x) (* x x)) 3) ;&rArr; 9</code></pre>
<h3 id="labels-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">labels</a> ((name lambda-list [[local-declare | local-doc]] local-forms*)*) [declare*] forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with a locally defined function. Functions defined by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">labels</a> are visible within <em>local-forms</em>, functions defined by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">flet</a> are not.</p>
<pre><code>(labels ((adder (a b)
           (+ a b))
         (adder1 (a b)
           (1+ (adder a b))))
  (adder1 4 3))               ;&rArr; 8

(flet ((adder (a b)
         (+ a b)))
  (adder 4 3))                ;&rArr; 7</code></pre>
<h3 id="function-name-function"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> name &rArr; function</h3>
<p>Return the lexically innermost <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> for <em>name</em>. The notation <code>#'</code> can be used as an abbreviation for <code>(function name)</code>.</p>
<pre><code>(funcall #&#39;list &#39;a &#39;b) ;&rArr; (A B)</code></pre>
<h3 id="funcall-function-rest-args-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_funcal.htm">funcall</a> function &amp;rest args* &rArr; result*</h3>
<p>Applies <em>function</em> to <em>args</em>.</p>
<pre><code>(funcall #&#39;+ 1 2 3) ;&rArr; 6</code></pre>
<h3 id="apply-function-args-arg-list-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_apply.htm">apply</a> function [args*] arg-list &rArr; result*</h3>
<p>Applies <em>function</em> to arguments in a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a>.</p>
<pre><code>(apply #&#39;+ &#39;(1 2 3))   ;&rArr; 6
(apply #&#39;+ 1 2 &#39;(3 4)) ;&rArr; 10</code></pre>
<h3 id="multiple-value-call-function-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_multip.htm">multiple-value-call</a> function forms* &rArr; result*</h3>
<p>Call <em>function</em> with all the values of each form as its arguments.</p>
<pre><code>(multiple-value-call #&#39;+ (floor 5.5) (floor 4.3)) ;= (+ 5 0.5 4 0.3) &rArr; 9.8</code></pre>
<h3 id="values-objects-objects"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_values.htm">values</a> objects* &rArr; objects*</h3>
<p>Return <em>objects</em> as multiple values. Is <code>setf</code>able.</p>
<pre><code>(values &#39;a &#39;b)      ;&rArr; A, B
(list (values 1 2)) ;&rArr; (A)

(multiple-value-bind (a b) (floor 7.5)
  (list a b))                          ;&rArr; (7 0.5)

(setf (values a b) (floor 7.5))
(list a b)                             ;&rArr; (7 0.5)</code></pre>
<h3 id="values-list-list-objects"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_vals_l.htm">values-list</a> list &rArr; objects*</h3>
<p>Return elements of <em>list</em> as multiple values.</p>
<pre><code>(values-list &#39;(A B)) ;&rArr; A, B

(multiple-value-bind (a b) (values-list &#39;(1 2))
  (list a b))  ;&rArr; (1 2)</code></pre>
<h3 id="multiple-value-list-form-list"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_mult_1.htm">multiple-value-list</a> form &rArr; list</h3>
<p>Evaluates <em>form</em> and creates a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_list.htm">list</a> of the multiple values it returns.</p>
<pre><code>(multiple-value-list (floor 7.5)) ;&rArr; (7 0.5)</code></pre>
<h3 id="nth-value-n-form-object"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_nth_va.htm">nth-value</a> n form &rArr; object</h3>
<p>Return the <em>n</em>th value yielded by <em>form</em>, zero-indexed.</p>
<pre><code>(nth-value 0 (values &#39;a &#39;b)) ;&rArr; A
(nth-value 1 (values &#39;a &#39;b)) ;&rArr; B</code></pre>
<h3 id="complement-function-complement-function"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_comple.htm">complement</a> function &rArr; complement-function</h3>
<p>Return new <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> with same arguments and side effects as <em>function</em>, but with the opposite truth value.</p>
<pre><code>(funcall (complement #&#39;numberp) 1)          ;&rArr; NIL
(funcall (complement #&#39;member) &#39;d &#39;(a b c)) ;&rArr; T

(complement fn) ;≈ #&#39;(lambda (&amp;rest args) (not (apply fn args)))</code></pre>
<h3 id="constantly-value-function"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cons_1.htm">constantly</a> value &rArr; function</h3>
<p>Returns a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> that always returns <em>value</em>, and takes any number of arguments.</p>
<pre><code>(mapcar (constantly 3) &#39;(a b c d)) ;&rArr; (3 3 3 3)</code></pre>
<h3 id="identity-object-object"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_identi.htm">identity</a> object &rArr; object</h3>
<p>Returns its argument <em>object</em>. Intended for use with functions that require a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_fn.htm">function</a> as an argument.</p>
<pre><code>(eql x (identity x)) ;&rArr; T</code></pre>
<h3 id="function-lambda-expression-function-lambda-expression-closure-p-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fn_lam.htm">function-lambda-expression</a> function &rArr; lambda-expression, closure-p, name</h3>
<p>If available, return lambda expression of <em>function</em>, `<a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_nil.htm">nil</a> if <em>function</em> was defined in an environment without bindings, and name of <em>function</em>.</p>
<pre><code>(function-lambda-expression (funcall #&#39;(lambda (x) #&#39;(lambda () x)) nil)) ;&rArr; NIL, T, NIL</code></pre>
<h3 id="fdefinition-name-definition"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fdefin.htm">fdefinition</a> name &rArr; definition</h3>
<p>Definition of global function foo; <code>setf</code>able.</p>
<pre><code>(fdefinition &#39;list) ;&rArr; #&lt;Compiled-function LIST&gt;</code></pre>
<h3 id="fmakunbound-name-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_fmakun.htm">fmakunbound</a> name &rArr; name</h3>
<p>Removes the function or macro definition, if any, of name in the global environment.</p>
<pre><code>(defun add-some (x) (+ x 19))   ;&rArr; ADD-SOME
(fboundp &#39;add-some)             ;&rArr; T
(flet ((add-some (x) (+ x 37)))
  (fmakunbound &#39;add-some)
  (add-some 1))                 ;&rArr; 38
(fboundp &#39;add-some)             ;&rArr; NIL</code></pre>
<h2 id="function-composition">Function Composition</h2>
<h3 id="alexandriacompose-fn-rest-fns-function"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-compose">alexandria:compose</a> fn &amp;rest fns* &rArr; function</h3>
<p>Compose function that applies its arguments to each in turn.</p>
<pre><code>(compose #&#39;fn2 #&#39;fn1) ;&rArr; (lambda (x) (fn2 (fn1 x)))</code></pre>
<h3 id="alexandriamultiple-value-compose-fn-rest-fns-function"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-multiple_002dvalue_002dcompose">alexandria:multiple-value-compose</a> fn &amp;rest fns* &rArr; function</h3>
<p>Compose functions that return multiple values. <em>fn1(x,y)</em> &rArr; <em>fn2(x1,y1)</em> &rArr; x2,y2</p>
<pre><code>(funcall (multiple-value-compose #&#39;fn2 #&#39;fn1) x y) ;&rArr; x2,y2</code></pre>
<h3 id="alexandriadisjoin-pred-rest-preds-function"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-disjoin">alexandria:disjoin</a> pred &amp;rest preds* &rArr; function</h3>
<pre><code>(disjoin #&#39;zerop #&#39;oddp) ;≈ (lambda (x) (or (zerop x) (oddp x)))</code></pre>
<h3 id="alexandriaconjoin-pred-rest-preds-function"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-conjoin">alexandria:conjoin</a> pred &amp;rest preds* &rArr; function</h3>
<pre><code>(conjoin #&#39;zerop #&#39;oddp) ;≈ (lambda (x) (and (zerop x) (oddp x)))</code></pre>
<h3 id="alexandriacurry-fn-rest-args-function"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-curry">alexandria:curry</a> fn &amp;rest args* &rArr; function</h3>
<pre><code>(funcall (curry #&#39;list &#39;a &#39;b) &#39;c &#39;d) ;&rArr; (A B C D)</code></pre>
<h3 id="alexandriarcurry-fn-rest-args-function"><a href="http://common-lisp.net/project/alexandria/draft/alexandria.html#Function-rcurry">alexandria:rcurry</a> fn &amp;rest args* &rArr; function</h3>
<pre><code>(funcall (rcurry #&#39;list &#39;a &#39;b) &#39;c &#39;d) ;&rArr; (C D A B)</code></pre>
<h2 id="macros">Macros</h2>
<p>The Common Lisp macro facility allows the user to define arbitrary functions that convert certain Lisp forms into different forms before evaluating or compiling them. This is done at the expression level, not at the character-string level as in most other languages. Macros are important in the writing of good code: they make it possible to write code that is clear and elegant at the user level but that is converted to a more complex or more efficient internal form for execution.</p>
<ul>
<li><a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node97.html">CLtL2: Macros</a></li>
<li><a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html">PCL: Macros: Defining Your Own</a></li>
</ul>
<h3 id="defmacro-name-lambda-list-declare-doc-forms-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defmac.htm">defmacro</a> name lambda-list [[declare* | doc]] forms* &rArr; name</h3>
<p>Define a macro with a given <em>name</em>, which acts as an implicit <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_block.htm">block</a> when evaluating <em>forms</em>. <code>define-compiler-macro</code> is similar with a few differences.</p>
<pre><code>(defmacro adder (a b)
  &quot;Sums two numbers and returns the result&quot;
  `(+ ,a ,b))

(adder 4 5) ;&rArr; 9</code></pre>
<h3 id="macrolet-name-lambda-list-local-declare-local-doc-local-forms-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">macrolet</a> ((name lambda-list [[local-declare | local-doc]] local-forms*)*) [declare*] forms* &rArr; result*</h3>
<p>Defines local macro definitions, using the same format used by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defmac.htm">defmacro</a>.</p>
<pre><code>(macrolet ((adder (a b) `(+ ,a ,b)))
  (adder 4 5))                       ;&rArr; 9</code></pre>
<h3 id="define-symbol-macro-symbol-expansion-symbol"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_1.htm">define-symbol-macro</a> symbol expansion &rArr; symbol</h3>
<p>Defines a macro expansion for <em>symbol</em>. <code>setf</code>able.</p>
<pre><code>(setf a &#39;(1 2 3))
(define-symbol-macro b (car a)) ;&rArr; B
b                               ;&rArr; 1
(setf b 5)
a                               ;&rArr; (5 2 3)
b                               ;&rArr; 5</code></pre>
<h3 id="symbol-macrolet-symbol-expansion-declare-forms-result"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_symbol.htm">symbol-macrolet</a> ((symbol expansion)*) declare* forms* &rArr; result*</h3>
<p>Evaluate <em>forms</em> with locally defined symbol macros.</p>
<pre><code>(symbol-macrolet ((x &#39;foo))
  (list x (let ((x &#39;bar)) x))) ;&rArr; (FOO BAR)</code></pre>
<h3 id="define-modify-macro-name-lambda-list-function-doc-name"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_2.htm">define-modify-macro</a> name lambda-list function [doc] &rArr; name</h3>
<p>Defines a macro to read and write a place.</p>
<pre><code>(define-modify-macro new-incf (&amp;optional (delta 1)) +)
(setf a 1)
(new-incf a) ;&rArr; 2</code></pre>
<h3 id="defsetf-access-fn-update-fn-doc-access-fn"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defset.htm">defsetf</a> access-fn update-fn [doc] &rArr; access-fn</h3>
<p>Specify how to <code>setf</code> a place accessed by function. There is a “short form” and “long form” of <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defset.htm">defsetf</a> as distinguished by the type of arguments.</p>
<pre><code>(defun middle (x)
  (nth (truncate (* (list-length x) 0.5)) x))
(defun set-middle (x val)
  (let ((idx (truncate (* (list-length x) 0.5))))
    (setf (nth idx x) val)))
(defsetf middle set-middle)

(setf a &#39;(a b c))   ;&rArr; (A B C)
(middle a)          ;&rArr; B
(setf (middle a) 2)
a                   ;&rArr; (A 2 C)</code></pre>
<h3 id="get-setf-expansion-place-optional-env-vars-vals-store-vars-writer-form-reader-form"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_get_se.htm">get-setf-expansion</a> place &amp;optional env &rArr; vars, vals, store-vars, writer-form, reader-form</h3>
<p>Returns lists of temporary variables, values, and get and set forms for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a> to read <em>place</em>.</p>
<pre><code>(defvar x)
(get-setf-expansion &#39;x) ;&rArr; NIL, NIL, (#:G6725), (SETQ X #:G6725), X</code></pre>
<ul>
<li><a href="http://www.lispworks.com/documentation/HyperSpec/Body/05_aab.htm">Setf Expansions</a></li>
</ul>
<h3 id="define-setf-expander-access-fn-lambda-list-declaration-doc-form-access-fn"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_3.htm">define-setf-expander</a> access-fn lambda-list [[declaration* | doc]] form* &rArr; access-fn</h3>
<p>Specifies the means by which <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_setf.htm">setf</a> updates a place that is referenced by <em>access-fn</em>.</p>
<pre><code>(defun last-element (x) (car (last x)))
(define-setf-expander last-element (x &amp;environment env)
  &quot;Set the last element in a list to the given value.&quot;
  (multiple-value-bind (dummies vals newval setter getter) (get-setf-expansion x env)
    (let ((store (gensym)))
          (values dummies
                  vals
                  `(,store)
                  `(progn (rplaca (last ,getter) ,store) ,store)
                  `(lastguy ,getter)))))

(setf l &#39;(a b c d))       ;&rArr; (A B C D)
(last-element l)          ;&rArr; D
(setf (last-element l) 4)
l                         ;&rArr; (A B C 4)</code></pre>
        </article>
      </div>
    </div>
    <footer></footer>
    
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script src="./include/bootstrap/js/bootstrap.js"></script>
		<script src="http://twitter.github.io/typeahead.js/releases/latest/typeahead.js"></script>
    <script src="./include/highlight/highlight-lisp.js"></script>
    <script src="./include/init.js"></script>
  </body>
</html>
